#!/usr/bin/python3
"""
Deploy an OStree commit

Create an OSTree deployment[1] for a given container image input
"""

import os
import subprocess
import sys

import osbuild.api
from osbuild.util import containers, ostree
from osbuild.util.mnt import MountGuard

import json

CAPABILITIES = ["CAP_MAC_ADMIN"]

SCHEMA_2 = """
"options": {
  "additionalProperties": false,
  "required": ["osname", "target_imgref"],
  "properties": {
    "mounts": {
      "description": "Mount points of the final file system",
      "type": "array",
      "items": {
        "description": "Description of one mount point",
        "type": "string"
      }
    },
    "osname": {
      "description": "Name of the stateroot to be used in the deployment",
      "type": "string"
    },
    "kernel_opts": {
      "description": "Additional kernel command line options",
      "type": "array",
      "items": {
        "description": "A single kernel command line option",
        "type": "string"
      }
    },
    "target_imgref": {
      "description": "imageref used as the source of truth for updates",
      "type": "string",
      "pattern": "^(ostree-remote-registry|ostree-image-signed|ostree-unverified-registry):.*$",
      "examples": ["ostree-remote-registry:fedora:quay.io/fedora/fedora-coreos:stable, ostree-image-signed:quay.io/fedora/fedora-coreos:stable, ostree-unverified-registry:quay.io/fedora/fedora-coreos:stable"]
    },
    "rootfs": {
      "description": "Identifier to locate the root file system",
      "type": "object",
      "oneOf": [{
        "required": ["uuid"]
      }, {
        "required": ["label"]
      }],
      "properties": {
        "label": {
          "description": "Identify the root file system by label",
          "type": "string"
        },
        "uuid": {
          "description": "Identify the root file system by UUID",
          "type": "string"
        }
      }
    }
  }
},
"inputs": {
  "type": "object",
  "additionalProperties": false,
  "required": ["images"],
  "properties": {
    "images": {
      "type": "object",
      "description": "Container Image to deploy",
      "additionalProperties": true
    }
  }
}
"""

def make_fs_identifier(desc):
    for key in ["uuid", "label"]:
        val = desc.get(key)
        if val:
            return f"{key.upper()}={val}"
    raise ValueError("unknown rootfs type")


def ostree_container_deploy(tree, inputs, osname, target_imgref, kopts):
    images = containers.parse_containers_input(inputs)
    for image in images.values():
        with containers.container_source(image) as (image_name, image_source):
            extra_args = []
            imgref = f"ostree-unverified-image:{image_source}"

            extra_args.append(f'--imgref={imgref}')
            extra_args.append(f'--stateroot={osname}')

            # consider implicit signature verification type checks, but
            # can't think of a "clean" way to do it yet other than
            # parsing the target-imgref and separating by the ':' character
            extra_args.append(f'--target-imgref={target_imgref}')

            kargs = [f'--karg={v}' for v in kopts]
            ostree.cli("container", "image", "deploy",
                       *extra_args, sysroot=tree, *kargs)

            # the `ostree container image metadata` command utilizes the
            # target-imgref, but only takes the name of the container image
            target_imgref_list = target_imgref.split(':')
            if target_imgref_list[0] == "ostree-remote-registry":
                target_imgref_name = ':'.join(target_imgref_list[2:])
            elif target_imgref_list[0] == ("ostree-image-signed" or "ostree-unverified-registry"):
                target_imgref_name = ':'.join(target_imgref_list[1:])
            
            container_data = subprocess.run(["ostree", "container", "image", "metadata", f"--repo={tree}/ostree/repo", f"registry:{target_imgref_name}"],
					check=True,
					capture_output=True,
					text=True).stdout.rstrip()
            
            container_data_config = subprocess.run(["ostree", "container", "image", "metadata", f"--repo={tree}/ostree/repo", f"registry:{target_imgref_name}", "--config"],
					check=True,
					capture_output=True,
					text=True).stdout.rstrip()
            
            container_data_json = json.loads(container_data)
            container_data_config_json = json.loads(container_data_config)

            aleph_digest = container_data_json['config']['digest']
            aleph_ref = f"docker://{target_imgref}"
            aleph_ostree_version = container_data_config_json['config']['Labels']['org.opencontainers.image.version']
            aleph_platform = "" # still up for discussion
            aleph_imgid = "" # still up for discussion
            aleph_container_image = container_data_config_json['config']['Labels']

            aleph_version_data = {
                "osbuild-version": osbuild.__version__,
                "ref": aleph_ref,
                "build": aleph_ostree_version,
                "version": aleph_ostree_version,
                "platform": aleph_platform,
                "imgid": aleph_imgid,
                "container-image": {
                    "image-name": image_name,
                    "image-digest": aleph_digest,
                    "image-labels": aleph_container_image
                }
            }
            
            # the 'ostree.commit' label will be optional in the future so
            # prevent hard failing if key is not found
            if 'ostree.commit' in container_data_config_json['config']['Labels']:
                aleph_ostree_commit = container_data_config_json['config']['Labels']['ostree.commit']
                aleph_version_data["ostree-commit"] = aleph_ostree_commit

            aleph_json = json.dumps(aleph_version_data, indent=4)
            with open(tree + "/.osbuild-container-aleph.json", "w") as outfile:
                outfile.write(aleph_json + "\n")
            outfile.close()


def main(tree, inputs, options):
    osname = options["osname"]
    rootfs = options.get("rootfs")
    mounts = options.get("mounts", [])
    kopts = options.get("kernel_opts", [])
    target_imgref = options.get("target_imgref")

    # schema should catch the case in which there are more
    # than one input but this adds a second layer of security
    if len(inputs) > 1:
        raise ValueError("Only one input accepted")

    if rootfs:
        rootfs_id = make_fs_identifier(rootfs)
        kopts += [f"root={rootfs_id}"]

    with MountGuard() as mounter:
        for mount in mounts:
            path = mount.lstrip("/")
            path = os.path.join(tree, path)
            mounter.mount(path, path)

        ostree_container_deploy(tree, inputs, osname, target_imgref, kopts)


if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    r = main(stage_args["tree"],
             stage_args["inputs"],
             stage_args["options"])
    sys.exit(r)
