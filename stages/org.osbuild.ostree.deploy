#!/usr/bin/python3
"""
Deploy an OStree commit

Create an OSTree deployment[1] for a given ref.

Since OStree internally uses a hardlink farm to create the file system tree
for the deployment from the commit data, the mountpoints for the final image
need to be supplied via the `mounts` option, as hardlinks must not span
across file systems and therefore the boundaries need to be known when doing
the deployment.

Creating a deployment also entails generating the Boot Loader Specification
entries to boot the system, which contain this the kernel command line.
The `rootfs` option can be used to indicate the root file system, containing
the sysroot and the deployments. Additional kernel options can be passed via
`kernel_opts`.

[1] https://ostree.readthedocs.io/en/latest/manual/deployment/
"""

import os
import subprocess
import sys
import tempfile

import osbuild.api
from osbuild.util import ostree
from osbuild.util.mnt import MountGuard
from osbuild.util import containers

CAPABILITIES = ["CAP_MAC_ADMIN"]

SCHEMA_2 = """
"options": {
  "additionalProperties": false,
  "required": ["osname", "ref"],
  "properties": {
    "mounts": {
      "description": "Mount points of the final file system",
      "type": "array",
      "items": {
        "description": "Description of one mount point",
        "type": "string"
      }
    },
    "osname": {
      "description": "Name of the stateroot to be used in the deployment",
      "type": "string"
    },
    "kernel_opts": {
      "description": "Additional kernel command line options",
      "type": "array",
      "items": {
        "description": "A single kernel command line option",
        "type": "string"
      }
    },
    "ref": {
      "description": "OStree ref to use for the deployment",
      "type": "string"
    },
    "remote": {
      "description": "optional OStree remote to use for the deployment",
      "type": "string"
    },
    "container": {
      "description": "Bool to indicate if the deployment is a container",
      "type": "boolean"
    },
    "rootfs": {
      "description": "Identifier to locate the root file system",
      "type": "object",
      "oneOf": [{
        "required": ["uuid"]
      }, {
        "required": ["label"]
      }],
      "properties": {
        "label": {
          "description": "Identify the root file system by label",
          "type": "string"
        },
        "uuid": {
          "description": "Identify the root file system by UUID",
          "type": "string"
        }
      }
    }
  }
},
"inputs": {
  "type": "object",
  "additionalProperties": false,
  "oneOf": [{
    "required": ["commits"]
  }, {
    "required": ["images"]
  }],
  "properties": {
    "commits": {
      "type": "object",
      "additionalProperties": true
    },
    "images": {
      "type": "object",
      "additionalProperties": true
    },
    "manifest-lists": {
      "type": "object",
      "description": "Optional manifest lists to merge into images. The metadata must specify an image ID to merge to.",
      "additionalProperties": true
    }
  }
}
"""


def make_fs_identifier(desc):
    for key in ["uuid", "label"]:
        val = desc.get(key)
        if val:
          return f"{key.upper()}={val}"
    raise ValueError("unknown rootfs type")


def main(tree, inputs, options):
    osname = options["osname"]
    rootfs = options.get("rootfs")
    mounts = options.get("mounts", [])
    kopts = options.get("kernel_opts", [])
    ref = options["ref"]
    remote = options.get("remote")

    print(inputs)
    print(tree)
    print(options)
    
    # distingush between ostree commit or container image input
    input_type = ''
    for key in inputs:
       input_type = key

    kargs = []

    if len(inputs) == 0:
      if remote:
          ref = f"{remote}:{ref}"

      if rootfs:
          rootfs_id = make_fs_identifier(rootfs)
          kargs += [f"--karg=root={rootfs_id}"]

      for opt in kopts:
          kargs += [f"--karg-append={opt}"]

    elif len(inputs) == 1:

        if input_type == 'images':
          for opt in kopts:
              kargs += [f"--karg={opt}"]

        elif input_type == 'commits':
          source_repo, commits = ostree.parse_ostree_input(inputs)
          target_repo = f"{tree}/ostree/repo"
          for commit, data in commits.items():
              loopref = data.get("ref", commit)
              ostree.pull_local(source_repo, target_repo, remote, loopref)
    
    # schema should catch the case in which there are more than one input but this adds a second layer of security
    elif len(inputs) > 1:
       raise ValueError("only one input accepted")

    with MountGuard() as mounter:
      for mount in mounts:
          path = mount.lstrip("/")
          path = os.path.join(tree, path)
          mounter.mount(path, path)
          
      if len(inputs) == 0:
        ostree.cli("admin", "deploy", ref,
                *kargs,
                sysroot=tree,
                os=osname)
      
      elif input_type == 'images':
        images = containers.parse_containers_input(inputs)
        for i in inputs["images"]:
            print(i)
        # create a temporary directory to store the ostree commit id after deploying the container image
        os.mkdir(f"{tree}/tmp")

        for image in images.values():
          with containers.container_source(image) as (image_name, image_source):
            extra_args = []
            imgref = f"{remote}:{image_source}"
            print(imgref)

            r = subprocess.run(["skopeo", "inspect", f"${imgref}"], check=True)
            print(r)

            if remote:
              extra_args.append(f'--imgref={imgref}')
              extra_args.append(f'--stateroot={osname}')
              extra_args.append(f'--write-commitid-to={tree}/tmp/commit.txt')
              # consider adding the target-imgref as a parameter
              # when parsing the inputs as a source, only the following data is stored:
              # inputs["images"] = [path, data]
                # inputs["images"]["path"] = /run/osbuild/inputs/images
                # inputs["images"]["data"] = {'archives': {'sha256:4b92d8b4188d4d4936bb749579936605b30231fcae82cb9c4b910d1b9a66f63f': {'format': 'dir', 'name': 'localhost/fcos'}}}
              extra_args.append('--target-imgref=ostree-unverified-registry:quay.io/fedora/fedora-coreos:stable')

            ostree.cli("container", "image", "deploy",
                  *extra_args,
                  sysroot=tree, 
                  *kargs)
        
      elif input_type == 'commits':
        ostree.cli("admin", "deploy", ref,
                    *kargs,
                    sysroot=tree,
                    os=osname)
          
if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    print(stage_args)
    r = main(stage_args["tree"],
             stage_args["inputs"],
             stage_args["options"])
    sys.exit(r)
