#!/usr/bin/python3
"""
Deploy an OStree commit

Create an OSTree deployment[1] for a given ref.

Since OStree internally uses a hardlink farm to create the file system tree
for the deployment from the commit data, the mountpoints for the final image
need to be supplied via the `mounts` option, as hardlinks must not span
across file systems and therefore the boundaries need to be known when doing
the deployment.

Creating a deployment also entails generating the Boot Loader Specification
entries to boot the system, which contain this the kernel command line.
The `rootfs` option can be used to indicate the root file system, containing
the sysroot and the deployments. Additional kernel options can be passed via
`kernel_opts`.

[1] https://ostree.readthedocs.io/en/latest/manual/deployment/
"""

import os
import sys

import osbuild.api
from osbuild.util import ostree
from osbuild.util.mnt import MountGuard

CAPABILITIES = ["CAP_MAC_ADMIN"]

SCHEMA_2 = """
"options": {
  "additionalProperties": false,
  "required": ["osname", "ref"],
  "properties": {
    "mounts": {
      "description": "Mount points of the final file system",
      "type": "array",
      "items": {
        "description": "Description of one mount point",
        "type": "string"
      }
    },
    "osname": {
      "description": "Name of the stateroot to be used in the deployment",
      "type": "string"
    },
    "kernel_opts": {
      "description": "Additional kernel command line options",
      "type": "array",
      "items": {
        "description": "A single kernel command line option",
        "type": "string"
      }
    },
    "ref": {
      "description": "OStree ref to use for the deployment",
      "type": "string"
    },
    "remote": {
      "description": "optional OStree remote to use for the deployment",
      "type": "string"
    },
    "container": {
      "description": "Bool to indicate if the deployment is a container",
      "type": "boolean"
    },
    "container-storage": {
      "type": "object",
      "properties": {
        "storage-path": {
          "description": "Container storage location (default /var/lib/containers/storage).",
          "type": "string"
        },
        "storage-driver": {
          "description": "The container storage driver to use (default overlay).",
          "type": "string"
        }
      }
    },
    "rootfs": {
      "description": "Identifier to locate the root file system",
      "type": "object",
      "oneOf": [{
        "required": ["uuid"]
      }, {
        "required": ["label"]
      }],
      "properties": {
        "label": {
          "description": "Identify the root file system by label",
          "type": "string"
        },
        "uuid": {
          "description": "Identify the root file system by UUID",
          "type": "string"
        }
      }
    }
  }
},
"inputs": {
  "type": "object",
  "required": ["commits"],
  "additionalProperties": false,
  "properties": {
    "commits": {
      "type": "object",
      "additionalProperties": true
    }
  }
}
"""


def make_fs_identifier(desc):
    for key in ["uuid", "label"]:
        val = desc.get(key)
        if val:
            return f"{key.upper()}={val}"
    raise ValueError("unknown rootfs type")


def main(tree, inputs, options):
    osname = options["osname"]
    rootfs = options.get("rootfs")
    mounts = options.get("mounts", [])
    kopts = options.get("kernel_opts", [])
    ref = options["ref"]
    remote = options.get("remote")
    is_container = options.get("container")

    # If provided an input then do the pull into the tree
    if len(inputs) != 0:
        source_repo, commits = ostree.parse_ostree_input(inputs)
        target_repo = f"{tree}/ostree/repo"
        for commit, data in commits.items():
            loopref = data.get("ref", commit)
            ostree.pull_local(source_repo, target_repo, remote, loopref)


    kargs = []

    if (not is_container):
      if remote:
          ref = f"{remote}:{ref}"

      if rootfs:
          rootfs_id = make_fs_identifier(rootfs)
          kargs += [f"--karg=root={rootfs_id}"]

      for opt in kopts:
          kargs += [f"--karg-append={opt}"]

    else:
      for opt in kopts:
          kargs += [f"--karg={opt}"]

    with MountGuard() as mounter:
        for mount in mounts:
            path = mount.lstrip("/")
            path = os.path.join(tree, path)
            mounter.mount(path, path)

        if (not is_container):
            ostree.cli("admin", "deploy", ref,
                       *kargs,
                       sysroot=tree,
                       os=osname)
        
        else:
            # create a temporary directory to store the ostree commit id after deploying the container image
            os.mkdir(f"{tree}/tmp")
            
            # parse and construct the imgref of the container image pulled during the skopeo stage
            destination = options["container-source"]
            storage_root = destination.get("storage-path", "/var/lib/containers/storage")
            storage_driver = destination.get("storage-driver", "overlay")

            imgref = f"{remote}:containers-storage:[{storage_driver}@{tree}{storage_root}+/run/containers/storage]{ref}"
            
            extra_args = []
            if remote:
                extra_args.append(f'--imgref={imgref}')
                extra_args.append(f'--stateroot={osname}')
                extra_args.append(f'--write-commitid-to={tree}/tmp/commit.txt')

            ostree.cli("container", "image", "deploy",
                       *extra_args,
                       sysroot=tree, 
                       *kargs)
            
            f = open(f'{tree}/tmp/commit.txt', 'r')
            commit = f.read()
            target = f"{tree}/ostree/deploy/{osname}/deploy/{commit}.0.origin"
            
            end_of_line = '$d'
            subprocess.run(["sed", "-i", f"{end_of_line}", target], check=True)
            
            remote_source = '$acontainer-image-reference=ostree-unverified-registry:quay.io/fedora/fedora-coreos:stable'
            subprocess.run(["sed", "-i", f"{remote_source}", target], check=True)

if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    r = main(stage_args["tree"],
             stage_args["inputs"],
             stage_args["options"])
    sys.exit(r)
