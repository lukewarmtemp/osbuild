#!/usr/bin/python3
"""
Deploy an OStree commit

Create an OSTree deployment[1] for a given ref.

Since OStree internally uses a hardlink farm to create the file system tree
for the deployment from the commit data, the mountpoints for the final image
need to be supplied via the `mounts` option, as hardlinks must not span
across file systems and therefore the boundaries need to be known when doing
the deployment.

Creating a deployment also entails generating the Boot Loader Specification
entries to boot the system, which contain this the kernel command line.
The `rootfs` option can be used to indicate the root file system, containing
the sysroot and the deployments. Additional kernel options can be passed via
`kernel_opts`.

[1] https://ostree.readthedocs.io/en/latest/manual/deployment/
"""

import os
import sys

import osbuild.api
from osbuild.util import containers, ostree
from osbuild.util.mnt import MountGuard

CAPABILITIES = ["CAP_MAC_ADMIN"]

SCHEMA_2 = """
"options": {
  "additionalProperties": false,
  "required": ["osname"],
  "properties": {
    "mounts": {
      "description": "Mount points of the final file system",
      "type": "array",
      "items": {
        "description": "Description of one mount point",
        "type": "string"
      }
    },
    "osname": {
      "description": "Name of the stateroot to be used in the deployment",
      "type": "string"
    },
    "kernel_opts": {
      "description": "Additional kernel command line options",
      "type": "array",
      "items": {
        "description": "A single kernel command line option",
        "type": "string"
      }
    },
    "ref": {
      "description": "OStree ref to use for the deployment",
      "type": "string"
    },
    "remote": {
      "description": "optional OStree remote to use for the deployment",
      "type": "string"
    },
    "target_signature_verification": {
      "description": "Set signature verification for ostree commit and container image updates",
      "type": "string",
      "enum": [
        "ostree-remote",
        "container-signing",
        "none"
      ]
    },
    "rootfs": {
      "description": "Identifier to locate the root file system",
      "type": "object",
      "oneOf": [{
        "required": ["uuid"]
      }, {
        "required": ["label"]
      }],
      "properties": {
        "label": {
          "description": "Identify the root file system by label",
          "type": "string"
        },
        "uuid": {
          "description": "Identify the root file system by UUID",
          "type": "string"
        }
      }
    }
  }
},
"inputs": {
  "type": "object",
  "additionalProperties": false,
  "oneOf": [{
    "required": ["commits"]
  }, {
    "required": ["images"]
  }, {
      "not": {
        "anyOf": [{
            "required": ["commits"]
          }, {
            "required": ["images"]
          }]
      }
  }],
  "properties": {
    "commits": {
      "type": "object",
      "description": "OStree commit to deploy",
      "additionalProperties": true
    },
    "images": {
      "type": "object",
      "description": "Container Image to deploy",
      "additionalProperties": true
    },
    "manifest-lists": {
      "type": "object",
      "description": "Optional manifest lists to merge into images. The metadata must specify an image ID to merge to.",
      "additionalProperties": true
    }
  }
}
"""


def make_fs_identifier(desc):
    for key in ["uuid", "label"]:
        val = desc.get(key)
        if val:
            return f"{key.upper()}={val}"
    raise ValueError("unknown rootfs type")


def ostree_commit_deploy(tree, inputs, osname, remote, ref, kopts):
    if len(inputs) == 0:
        if not ref:
            raise ValueError("ref should be specified in options")
    elif len(inputs) == 1:
        if ref:
            raise ValueError("Should not specify ref if input was specified")

        # If we have an input then we need to pull_local() from the input
        # first before we deploy.
        source_repo, commits = ostree.parse_input_commits(inputs["commits"])
        target_repo = f"{tree}/ostree/repo"
        for commit, data in commits.items():
            ref = data.get("ref", commit)
            ostree.pull_local(source_repo, target_repo, remote, ref)

    if remote:
        ref = f"{remote}:{ref}"

    kargs = [f'--karg-append={v}' for v in kopts]
    ostree.cli("admin", "deploy", ref,
               *kargs, sysroot=tree, os=osname)


def ostree_container_deploy(tree, inputs, osname, remote, verification_type, kopts):
    if verification_type == "ostree-remote" and not remote:
        raise ValueError("missing remote for ostree remote registry signature verification")

    images = containers.parse_containers_input(inputs)
    for image in images.values():
        with containers.container_source(image) as (image_name, image_source):
            extra_args = []
            imgref = f"ostree-unverified-image:{image_source}"

            if verification_type == "ostree-remote":
                target_imgref = f'ostree-remote-registry:{remote}:{image_name}'
            elif verification_type == "container-signing":
                target_imgref = f'ostree-image-signed:registry:{image_name}'
            elif verification_type == "none":
                target_imgref = f'ostree-unverified-registry:{image_name}'

            extra_args.append(f'--imgref={imgref}')
            extra_args.append(f'--stateroot={osname}')
            extra_args.append(f'--target-imgref={target_imgref}')

            kargs = [f'--karg={v}' for v in kopts]

            ostree.cli("container", "image", "deploy",
                       *extra_args, sysroot=tree, *kargs)


def main(tree, inputs, options):
    osname = options["osname"]
    rootfs = options.get("rootfs")
    mounts = options.get("mounts", [])
    kopts = options.get("kernel_opts", [])
    ref = options.get("ref", "")
    remote = options.get("remote")
    target_signature_verification = options.get("target_signature_verification", "container-signing")

    # schema should catch the case in which there are more
    # than one input but this adds a second layer of security
    if len(inputs) > 1:
        raise ValueError("Only one input accepted")

    # distingush between ostree commit or container image input
    input_type = None
    for key in inputs:
        input_type = key

    if rootfs:
        rootfs_id = make_fs_identifier(rootfs)
        kopts += [f"root={rootfs_id}"]

    with MountGuard() as mounter:
        for mount in mounts:
            path = mount.lstrip("/")
            path = os.path.join(tree, path)
            mounter.mount(path, path)

        if input_type == 'images':
            ostree_container_deploy(tree, inputs, osname, remote, target_signature_verification, kopts)
        else:
            ostree_commit_deploy(tree, inputs, osname, remote, ref, kopts)


if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    r = main(stage_args["tree"],
             stage_args["inputs"],
             stage_args["options"])
    sys.exit(r)
